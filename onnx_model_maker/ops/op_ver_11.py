# Autogenerated by onnx-model-maker. Don't modify it manually.

import onnx
import onnx.helper
import onnx.numpy_helper
from onnx_model_maker import omm
from onnx_model_maker import onnx_mm_export
from onnx_model_maker.ops.op_helper import _add_input


@onnx_mm_export("v11.Gemm")
def Gemm(A, B, C=None, **kwargs):
  _inputs = []
  for i in (A, B, C):
    _add_input(i, _inputs)

  idx = omm.op_counter["Gemm"]
  omm.op_counter["Gemm"] += 1
  node = onnx.helper.make_node("Gemm",
                               _inputs, [f'_t_Gemm_{idx}_Y'],
                               name=f"Gemm_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.ConcatFromSequence")
def ConcatFromSequence(input_sequence, **kwargs):
  _inputs = []
  for i in (input_sequence, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ConcatFromSequence"]
  omm.op_counter["ConcatFromSequence"] += 1
  node = onnx.helper.make_node("ConcatFromSequence",
                               _inputs, [f'_t_ConcatFromSequence_{idx}_concat_result'],
                               name=f"ConcatFromSequence_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.SequenceAt")
def SequenceAt(input_sequence, position, **kwargs):
  _inputs = []
  for i in (input_sequence, position):
    _add_input(i, _inputs)

  idx = omm.op_counter["SequenceAt"]
  omm.op_counter["SequenceAt"] += 1
  node = onnx.helper.make_node("SequenceAt",
                               _inputs, [f'_t_SequenceAt_{idx}_tensor'],
                               name=f"SequenceAt_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.SequenceInsert")
def SequenceInsert(input_sequence, tensor, position=None, **kwargs):
  _inputs = []
  for i in (input_sequence, tensor, position):
    _add_input(i, _inputs)

  idx = omm.op_counter["SequenceInsert"]
  omm.op_counter["SequenceInsert"] += 1
  node = onnx.helper.make_node("SequenceInsert",
                               _inputs, [f'_t_SequenceInsert_{idx}_output_sequence'],
                               name=f"SequenceInsert_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.GatherND")
def GatherND(data, indices, **kwargs):
  _inputs = []
  for i in (data, indices):
    _add_input(i, _inputs)

  idx = omm.op_counter["GatherND"]
  omm.op_counter["GatherND"] += 1
  node = onnx.helper.make_node("GatherND",
                               _inputs, [f'_t_GatherND_{idx}_output'],
                               name=f"GatherND_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.ScatterND")
def ScatterND(data, indices, updates, **kwargs):
  _inputs = []
  for i in (data, indices, updates):
    _add_input(i, _inputs)

  idx = omm.op_counter["ScatterND"]
  omm.op_counter["ScatterND"] += 1
  node = onnx.helper.make_node("ScatterND",
                               _inputs, [f'_t_ScatterND_{idx}_output'],
                               name=f"ScatterND_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Det")
def Det(X, **kwargs):
  _inputs = []
  for i in (X, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Det"]
  omm.op_counter["Det"] += 1
  node = onnx.helper.make_node("Det",
                               _inputs, [f'_t_Det_{idx}_Y'],
                               name=f"Det_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.ScatterElements")
def ScatterElements(data, indices, updates, **kwargs):
  _inputs = []
  for i in (data, indices, updates):
    _add_input(i, _inputs)

  idx = omm.op_counter["ScatterElements"]
  omm.op_counter["ScatterElements"] += 1
  node = onnx.helper.make_node("ScatterElements",
                               _inputs, [f'_t_ScatterElements_{idx}_output'],
                               name=f"ScatterElements_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.BitShift")
def BitShift(X, Y, **kwargs):
  _inputs = []
  for i in (X, Y):
    _add_input(i, _inputs)

  idx = omm.op_counter["BitShift"]
  omm.op_counter["BitShift"] += 1
  node = onnx.helper.make_node("BitShift",
                               _inputs, [f'_t_BitShift_{idx}_Z'],
                               name=f"BitShift_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.GatherElements")
def GatherElements(data, indices, **kwargs):
  _inputs = []
  for i in (data, indices):
    _add_input(i, _inputs)

  idx = omm.op_counter["GatherElements"]
  omm.op_counter["GatherElements"] += 1
  node = onnx.helper.make_node("GatherElements",
                               _inputs, [f'_t_GatherElements_{idx}_output'],
                               name=f"GatherElements_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.SplitToSequence")
def SplitToSequence(input, split=None, **kwargs):
  _inputs = []
  for i in (input, split):
    _add_input(i, _inputs)

  idx = omm.op_counter["SplitToSequence"]
  omm.op_counter["SplitToSequence"] += 1
  node = onnx.helper.make_node("SplitToSequence",
                               _inputs, [f'_t_SplitToSequence_{idx}_output_sequence'],
                               name=f"SplitToSequence_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.DynamicQuantizeLinear")
def DynamicQuantizeLinear(x, **kwargs):
  _inputs = []
  for i in (x, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["DynamicQuantizeLinear"]
  omm.op_counter["DynamicQuantizeLinear"] += 1
  node = onnx.helper.make_node("DynamicQuantizeLinear",
                               _inputs, [f'_t_DynamicQuantizeLinear_{idx}_y', f'_t_DynamicQuantizeLinear_{idx}_y_scale', f'_t_DynamicQuantizeLinear_{idx}_y_zero_point'],
                               name=f"DynamicQuantizeLinear_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Round")
def Round(X, **kwargs):
  _inputs = []
  for i in (X, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Round"]
  omm.op_counter["Round"] += 1
  node = onnx.helper.make_node("Round",
                               _inputs, [f'_t_Round_{idx}_Y'],
                               name=f"Round_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.CumSum")
def CumSum(x, axis, **kwargs):
  _inputs = []
  for i in (x, axis):
    _add_input(i, _inputs)

  idx = omm.op_counter["CumSum"]
  omm.op_counter["CumSum"] += 1
  node = onnx.helper.make_node("CumSum",
                               _inputs, [f'_t_CumSum_{idx}_y'],
                               name=f"CumSum_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.NonMaxSuppression")
def NonMaxSuppression(boxes, scores, max_output_boxes_per_class=None, iou_threshold=None, score_threshold=None, **kwargs):
  _inputs = []
  for i in (boxes, scores, max_output_boxes_per_class, iou_threshold, score_threshold):
    _add_input(i, _inputs)

  idx = omm.op_counter["NonMaxSuppression"]
  omm.op_counter["NonMaxSuppression"] += 1
  node = onnx.helper.make_node("NonMaxSuppression",
                               _inputs, [f'_t_NonMaxSuppression_{idx}_selected_indices'],
                               name=f"NonMaxSuppression_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Equal")
def Equal(A, B, **kwargs):
  _inputs = []
  for i in (A, B):
    _add_input(i, _inputs)

  idx = omm.op_counter["Equal"]
  omm.op_counter["Equal"] += 1
  node = onnx.helper.make_node("Equal",
                               _inputs, [f'_t_Equal_{idx}_C'],
                               name=f"Equal_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.LpPool")
def LpPool(X, **kwargs):
  _inputs = []
  for i in (X, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["LpPool"]
  omm.op_counter["LpPool"] += 1
  node = onnx.helper.make_node("LpPool",
                               _inputs, [f'_t_LpPool_{idx}_Y'],
                               name=f"LpPool_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.LogSoftmax")
def LogSoftmax(input, **kwargs):
  _inputs = []
  for i in (input, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["LogSoftmax"]
  omm.op_counter["LogSoftmax"] += 1
  node = onnx.helper.make_node("LogSoftmax",
                               _inputs, [f'_t_LogSoftmax_{idx}_output'],
                               name=f"LogSoftmax_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Range")
def Range(start, limit, delta, **kwargs):
  _inputs = []
  for i in (start, limit, delta):
    _add_input(i, _inputs)

  idx = omm.op_counter["Range"]
  omm.op_counter["Range"] += 1
  node = onnx.helper.make_node("Range",
                               _inputs, [f'_t_Range_{idx}_output'],
                               name=f"Range_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Gather")
def Gather(data, indices, **kwargs):
  _inputs = []
  for i in (data, indices):
    _add_input(i, _inputs)

  idx = omm.op_counter["Gather"]
  omm.op_counter["Gather"] += 1
  node = onnx.helper.make_node("Gather",
                               _inputs, [f'_t_Gather_{idx}_output'],
                               name=f"Gather_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.SequenceErase")
def SequenceErase(input_sequence, position=None, **kwargs):
  _inputs = []
  for i in (input_sequence, position):
    _add_input(i, _inputs)

  idx = omm.op_counter["SequenceErase"]
  omm.op_counter["SequenceErase"] += 1
  node = onnx.helper.make_node("SequenceErase",
                               _inputs, [f'_t_SequenceErase_{idx}_output_sequence'],
                               name=f"SequenceErase_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Scatter")
def Scatter(data, indices, updates, **kwargs):
  _inputs = []
  for i in (data, indices, updates):
    _add_input(i, _inputs)

  idx = omm.op_counter["Scatter"]
  omm.op_counter["Scatter"] += 1
  node = onnx.helper.make_node("Scatter",
                               _inputs, [f'_t_Scatter_{idx}_output'],
                               name=f"Scatter_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.OneHot")
def OneHot(indices, depth, values, **kwargs):
  _inputs = []
  for i in (indices, depth, values):
    _add_input(i, _inputs)

  idx = omm.op_counter["OneHot"]
  omm.op_counter["OneHot"] += 1
  node = onnx.helper.make_node("OneHot",
                               _inputs, [f'_t_OneHot_{idx}_output'],
                               name=f"OneHot_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.ReduceProd")
def ReduceProd(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceProd"]
  omm.op_counter["ReduceProd"] += 1
  node = onnx.helper.make_node("ReduceProd",
                               _inputs, [f'_t_ReduceProd_{idx}_reduced'],
                               name=f"ReduceProd_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.MaxUnpool")
def MaxUnpool(X, I, output_shape=None, **kwargs):
  _inputs = []
  for i in (X, I, output_shape):
    _add_input(i, _inputs)

  idx = omm.op_counter["MaxUnpool"]
  omm.op_counter["MaxUnpool"] += 1
  node = onnx.helper.make_node("MaxUnpool",
                               _inputs, [f'_t_MaxUnpool_{idx}_output'],
                               name=f"MaxUnpool_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Compress")
def Compress(input, condition, **kwargs):
  _inputs = []
  for i in (input, condition):
    _add_input(i, _inputs)

  idx = omm.op_counter["Compress"]
  omm.op_counter["Compress"] += 1
  node = onnx.helper.make_node("Compress",
                               _inputs, [f'_t_Compress_{idx}_output'],
                               name=f"Compress_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Scan")
def Scan(initial_state_and_scan_inputs, **kwargs):
  _inputs = []
  for i in (initial_state_and_scan_inputs, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Scan"]
  omm.op_counter["Scan"] += 1
  node = onnx.helper.make_node("Scan",
                               _inputs, [f'_t_Scan_{idx}_final_state_and_scan_outputs'],
                               name=f"Scan_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.ReduceL1")
def ReduceL1(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceL1"]
  omm.op_counter["ReduceL1"] += 1
  node = onnx.helper.make_node("ReduceL1",
                               _inputs, [f'_t_ReduceL1_{idx}_reduced'],
                               name=f"ReduceL1_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.ReduceSum")
def ReduceSum(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceSum"]
  omm.op_counter["ReduceSum"] += 1
  node = onnx.helper.make_node("ReduceSum",
                               _inputs, [f'_t_ReduceSum_{idx}_reduced'],
                               name=f"ReduceSum_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.ReduceSumSquare")
def ReduceSumSquare(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceSumSquare"]
  omm.op_counter["ReduceSumSquare"] += 1
  node = onnx.helper.make_node("ReduceSumSquare",
                               _inputs, [f'_t_ReduceSumSquare_{idx}_reduced'],
                               name=f"ReduceSumSquare_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Squeeze")
def Squeeze(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Squeeze"]
  omm.op_counter["Squeeze"] += 1
  node = onnx.helper.make_node("Squeeze",
                               _inputs, [f'_t_Squeeze_{idx}_squeezed'],
                               name=f"Squeeze_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.ReduceLogSum")
def ReduceLogSum(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceLogSum"]
  omm.op_counter["ReduceLogSum"] += 1
  node = onnx.helper.make_node("ReduceLogSum",
                               _inputs, [f'_t_ReduceLogSum_{idx}_reduced'],
                               name=f"ReduceLogSum_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Split")
def Split(input, **kwargs):
  _inputs = []
  for i in (input, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Split"]
  omm.op_counter["Split"] += 1
  node = onnx.helper.make_node("Split",
                               _inputs, [f"_t_Split_{idx}_{i}" for i in range(len(kwargs["split"]))],
                               name=f"Split_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Softmax")
def Softmax(input, **kwargs):
  _inputs = []
  for i in (input, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Softmax"]
  omm.op_counter["Softmax"] += 1
  node = onnx.helper.make_node("Softmax",
                               _inputs, [f'_t_Softmax_{idx}_output'],
                               name=f"Softmax_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.AveragePool")
def AveragePool(X, **kwargs):
  _inputs = []
  for i in (X, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["AveragePool"]
  omm.op_counter["AveragePool"] += 1
  node = onnx.helper.make_node("AveragePool",
                               _inputs, [f'_t_AveragePool_{idx}_Y'],
                               name=f"AveragePool_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.TopK")
def TopK(X, K, **kwargs):
  _inputs = []
  for i in (X, K):
    _add_input(i, _inputs)

  idx = omm.op_counter["TopK"]
  omm.op_counter["TopK"] += 1
  node = onnx.helper.make_node("TopK",
                               _inputs, [f'_t_TopK_{idx}_Values', f'_t_TopK_{idx}_Indices'],
                               name=f"TopK_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.SequenceLength")
def SequenceLength(input_sequence, **kwargs):
  _inputs = []
  for i in (input_sequence, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["SequenceLength"]
  omm.op_counter["SequenceLength"] += 1
  node = onnx.helper.make_node("SequenceLength",
                               _inputs, [f'_t_SequenceLength_{idx}_length'],
                               name=f"SequenceLength_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.ReduceMin")
def ReduceMin(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceMin"]
  omm.op_counter["ReduceMin"] += 1
  node = onnx.helper.make_node("ReduceMin",
                               _inputs, [f'_t_ReduceMin_{idx}_reduced'],
                               name=f"ReduceMin_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.ConvTranspose")
def ConvTranspose(X, W, B=None, **kwargs):
  _inputs = []
  for i in (X, W, B):
    _add_input(i, _inputs)

  idx = omm.op_counter["ConvTranspose"]
  omm.op_counter["ConvTranspose"] += 1
  node = onnx.helper.make_node("ConvTranspose",
                               _inputs, [f'_t_ConvTranspose_{idx}_Y'],
                               name=f"ConvTranspose_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Pad")
def Pad(data, pads, constant_value=None, **kwargs):
  _inputs = []
  for i in (data, pads, constant_value):
    _add_input(i, _inputs)

  idx = omm.op_counter["Pad"]
  omm.op_counter["Pad"] += 1
  node = onnx.helper.make_node("Pad",
                               _inputs, [f'_t_Pad_{idx}_output'],
                               name=f"Pad_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Conv")
def Conv(X, W, B=None, **kwargs):
  _inputs = []
  for i in (X, W, B):
    _add_input(i, _inputs)

  idx = omm.op_counter["Conv"]
  omm.op_counter["Conv"] += 1
  node = onnx.helper.make_node("Conv",
                               _inputs, [f'_t_Conv_{idx}_Y'],
                               name=f"Conv_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Slice")
def Slice(data, starts, ends, axes=None, steps=None, **kwargs):
  _inputs = []
  for i in (data, starts, ends, axes, steps):
    _add_input(i, _inputs)

  idx = omm.op_counter["Slice"]
  omm.op_counter["Slice"] += 1
  node = onnx.helper.make_node("Slice",
                               _inputs, [f'_t_Slice_{idx}_output'],
                               name=f"Slice_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.ReduceLogSumExp")
def ReduceLogSumExp(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceLogSumExp"]
  omm.op_counter["ReduceLogSumExp"] += 1
  node = onnx.helper.make_node("ReduceLogSumExp",
                               _inputs, [f'_t_ReduceLogSumExp_{idx}_reduced'],
                               name=f"ReduceLogSumExp_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.ReduceL2")
def ReduceL2(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceL2"]
  omm.op_counter["ReduceL2"] += 1
  node = onnx.helper.make_node("ReduceL2",
                               _inputs, [f'_t_ReduceL2_{idx}_reduced'],
                               name=f"ReduceL2_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Flatten")
def Flatten(input, **kwargs):
  _inputs = []
  for i in (input, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Flatten"]
  omm.op_counter["Flatten"] += 1
  node = onnx.helper.make_node("Flatten",
                               _inputs, [f'_t_Flatten_{idx}_output'],
                               name=f"Flatten_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.ReduceMax")
def ReduceMax(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceMax"]
  omm.op_counter["ReduceMax"] += 1
  node = onnx.helper.make_node("ReduceMax",
                               _inputs, [f'_t_ReduceMax_{idx}_reduced'],
                               name=f"ReduceMax_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Loop")
def Loop(M, cond, v_initial=None, **kwargs):
  _inputs = []
  for i in (M, cond, v_initial):
    _add_input(i, _inputs)

  idx = omm.op_counter["Loop"]
  omm.op_counter["Loop"] += 1
  node = onnx.helper.make_node("Loop",
                               _inputs, [f'_t_Loop_{idx}_v_final_and_scan_outputs'],
                               name=f"Loop_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Unsqueeze")
def Unsqueeze(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Unsqueeze"]
  omm.op_counter["Unsqueeze"] += 1
  node = onnx.helper.make_node("Unsqueeze",
                               _inputs, [f'_t_Unsqueeze_{idx}_expanded'],
                               name=f"Unsqueeze_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.ArgMax")
def ArgMax(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ArgMax"]
  omm.op_counter["ArgMax"] += 1
  node = onnx.helper.make_node("ArgMax",
                               _inputs, [f'_t_ArgMax_{idx}_reduced'],
                               name=f"ArgMax_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.SequenceEmpty")
def SequenceEmpty(**kwargs):
  _inputs = []
  for i in ():
    _add_input(i, _inputs)

  idx = omm.op_counter["SequenceEmpty"]
  omm.op_counter["SequenceEmpty"] += 1
  node = onnx.helper.make_node("SequenceEmpty",
                               _inputs, [f'_t_SequenceEmpty_{idx}_output'],
                               name=f"SequenceEmpty_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Concat")
def Concat(inputs, **kwargs):
  _inputs = []
  for i in (inputs, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Concat"]
  omm.op_counter["Concat"] += 1
  node = onnx.helper.make_node("Concat",
                               _inputs, [f'_t_Concat_{idx}_concat_result'],
                               name=f"Concat_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.If")
def If(cond, **kwargs):
  _inputs = []
  for i in (cond, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["If"]
  omm.op_counter["If"] += 1
  node = onnx.helper.make_node("If",
                               _inputs, [f'_t_If_{idx}_outputs'],
                               name=f"If_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Clip")
def Clip(input, min=None, max=None, **kwargs):
  _inputs = []
  for i in (input, min, max):
    _add_input(i, _inputs)

  idx = omm.op_counter["Clip"]
  omm.op_counter["Clip"] += 1
  node = onnx.helper.make_node("Clip",
                               _inputs, [f'_t_Clip_{idx}_output'],
                               name=f"Clip_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Resize")
def Resize(X, roi, scales, sizes=None, **kwargs):
  _inputs = []
  for i in (X, roi, scales, sizes):
    _add_input(i, _inputs)

  idx = omm.op_counter["Resize"]
  omm.op_counter["Resize"] += 1
  node = onnx.helper.make_node("Resize",
                               _inputs, [f'_t_Resize_{idx}_Y'],
                               name=f"Resize_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.SequenceConstruct")
def SequenceConstruct(inputs, **kwargs):
  _inputs = []
  for i in (inputs, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["SequenceConstruct"]
  omm.op_counter["SequenceConstruct"] += 1
  node = onnx.helper.make_node("SequenceConstruct",
                               _inputs, [f'_t_SequenceConstruct_{idx}_output_sequence'],
                               name=f"SequenceConstruct_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Unique")
def Unique(X, **kwargs):
  _inputs = []
  for i in (X, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Unique"]
  omm.op_counter["Unique"] += 1
  node = onnx.helper.make_node("Unique",
                               _inputs, [f'_t_Unique_{idx}_Y', f'_t_Unique_{idx}_indices', f'_t_Unique_{idx}_inverse_indices', f'_t_Unique_{idx}_counts'],
                               name=f"Unique_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.ArgMin")
def ArgMin(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ArgMin"]
  omm.op_counter["ArgMin"] += 1
  node = onnx.helper.make_node("ArgMin",
                               _inputs, [f'_t_ArgMin_{idx}_reduced'],
                               name=f"ArgMin_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Constant")
def Constant(**kwargs):
  _inputs = []
  for i in ():
    _add_input(i, _inputs)

  idx = omm.op_counter["Constant"]
  omm.op_counter["Constant"] += 1
  node = onnx.helper.make_node("Constant",
                               _inputs, [f'_t_Constant_{idx}_output'],
                               name=f"Constant_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.MaxPool")
def MaxPool(X, **kwargs):
  _inputs = []
  for i in (X, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["MaxPool"]
  omm.op_counter["MaxPool"] += 1
  node = onnx.helper.make_node("MaxPool",
                               _inputs, [f'_t_MaxPool_{idx}_Y', f'_t_MaxPool_{idx}_Indices'],
                               name=f"MaxPool_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.ReduceMean")
def ReduceMean(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceMean"]
  omm.op_counter["ReduceMean"] += 1
  node = onnx.helper.make_node("ReduceMean",
                               _inputs, [f'_t_ReduceMean_{idx}_reduced'],
                               name=f"ReduceMean_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.DepthToSpace")
def DepthToSpace(input, **kwargs):
  _inputs = []
  for i in (input, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["DepthToSpace"]
  omm.op_counter["DepthToSpace"] += 1
  node = onnx.helper.make_node("DepthToSpace",
                               _inputs, [f'_t_DepthToSpace_{idx}_output'],
                               name=f"DepthToSpace_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v11.Hardmax")
def Hardmax(input, **kwargs):
  _inputs = []
  for i in (input, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Hardmax"]
  omm.op_counter["Hardmax"] += 1
  node = onnx.helper.make_node("Hardmax",
                               _inputs, [f'_t_Hardmax_{idx}_output'],
                               name=f"Hardmax_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node
