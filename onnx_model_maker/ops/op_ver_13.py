# Autogenerated by onnx-model-maker. Don't modify it manually.

import onnx
import onnx.helper
import onnx.numpy_helper
from onnx_model_maker import omm
from onnx_model_maker import onnx_mm_export
from onnx_model_maker.ops.op_helper import _add_input


@onnx_mm_export("v13.Sigmoid")
def Sigmoid(X, **kwargs):
  _inputs = []
  for i in (X, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Sigmoid"]
  omm.op_counter["Sigmoid"] += 1
  node = onnx.helper.make_node("Sigmoid",
                               _inputs, [f'_t_Sigmoid_{idx}_Y'],
                               name=f"Sigmoid_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Gemm")
def Gemm(A, B, C=None, **kwargs):
  _inputs = []
  for i in (A, B, C):
    _add_input(i, _inputs)

  idx = omm.op_counter["Gemm"]
  omm.op_counter["Gemm"] += 1
  node = onnx.helper.make_node("Gemm",
                               _inputs, [f'_t_Gemm_{idx}_Y'],
                               name=f"Gemm_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.GatherND")
def GatherND(data, indices, **kwargs):
  _inputs = []
  for i in (data, indices):
    _add_input(i, _inputs)

  idx = omm.op_counter["GatherND"]
  omm.op_counter["GatherND"] += 1
  node = onnx.helper.make_node("GatherND",
                               _inputs, [f'_t_GatherND_{idx}_output'],
                               name=f"GatherND_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.ScatterND")
def ScatterND(data, indices, updates, **kwargs):
  _inputs = []
  for i in (data, indices, updates):
    _add_input(i, _inputs)

  idx = omm.op_counter["ScatterND"]
  omm.op_counter["ScatterND"] += 1
  node = onnx.helper.make_node("ScatterND",
                               _inputs, [f'_t_ScatterND_{idx}_output'],
                               name=f"ScatterND_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.ScatterElements")
def ScatterElements(data, indices, updates, **kwargs):
  _inputs = []
  for i in (data, indices, updates):
    _add_input(i, _inputs)

  idx = omm.op_counter["ScatterElements"]
  omm.op_counter["ScatterElements"] += 1
  node = onnx.helper.make_node("ScatterElements",
                               _inputs, [f'_t_ScatterElements_{idx}_output'],
                               name=f"ScatterElements_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.GatherElements")
def GatherElements(data, indices, **kwargs):
  _inputs = []
  for i in (data, indices):
    _add_input(i, _inputs)

  idx = omm.op_counter["GatherElements"]
  omm.op_counter["GatherElements"] += 1
  node = onnx.helper.make_node("GatherElements",
                               _inputs, [f'_t_GatherElements_{idx}_output'],
                               name=f"GatherElements_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Reciprocal")
def Reciprocal(X, **kwargs):
  _inputs = []
  for i in (X, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Reciprocal"]
  omm.op_counter["Reciprocal"] += 1
  node = onnx.helper.make_node("Reciprocal",
                               _inputs, [f'_t_Reciprocal_{idx}_Y'],
                               name=f"Reciprocal_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Equal")
def Equal(A, B, **kwargs):
  _inputs = []
  for i in (A, B):
    _add_input(i, _inputs)

  idx = omm.op_counter["Equal"]
  omm.op_counter["Equal"] += 1
  node = onnx.helper.make_node("Equal",
                               _inputs, [f'_t_Equal_{idx}_C'],
                               name=f"Equal_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.QuantizeLinear")
def QuantizeLinear(x, y_scale, y_zero_point=None, **kwargs):
  _inputs = []
  for i in (x, y_scale, y_zero_point):
    _add_input(i, _inputs)

  idx = omm.op_counter["QuantizeLinear"]
  omm.op_counter["QuantizeLinear"] += 1
  node = onnx.helper.make_node("QuantizeLinear",
                               _inputs, [f'_t_QuantizeLinear_{idx}_y'],
                               name=f"QuantizeLinear_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.MeanVarianceNormalization")
def MeanVarianceNormalization(X, **kwargs):
  _inputs = []
  for i in (X, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["MeanVarianceNormalization"]
  omm.op_counter["MeanVarianceNormalization"] += 1
  node = onnx.helper.make_node("MeanVarianceNormalization",
                               _inputs, [f'_t_MeanVarianceNormalization_{idx}_Y'],
                               name=f"MeanVarianceNormalization_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.LogSoftmax")
def LogSoftmax(input, **kwargs):
  _inputs = []
  for i in (input, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["LogSoftmax"]
  omm.op_counter["LogSoftmax"] += 1
  node = onnx.helper.make_node("LogSoftmax",
                               _inputs, [f'_t_LogSoftmax_{idx}_output'],
                               name=f"LogSoftmax_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Gather")
def Gather(data, indices, **kwargs):
  _inputs = []
  for i in (data, indices):
    _add_input(i, _inputs)

  idx = omm.op_counter["Gather"]
  omm.op_counter["Gather"] += 1
  node = onnx.helper.make_node("Gather",
                               _inputs, [f'_t_Gather_{idx}_output'],
                               name=f"Gather_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.NonZero")
def NonZero(X, **kwargs):
  _inputs = []
  for i in (X, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["NonZero"]
  omm.op_counter["NonZero"] += 1
  node = onnx.helper.make_node("NonZero",
                               _inputs, [f'_t_NonZero_{idx}_Y'],
                               name=f"NonZero_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Mean")
def Mean(data_0, **kwargs):
  _inputs = []
  for i in (data_0, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Mean"]
  omm.op_counter["Mean"] += 1
  node = onnx.helper.make_node("Mean",
                               _inputs, [f'_t_Mean_{idx}_mean'],
                               name=f"Mean_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Sub")
def Sub(A, B, **kwargs):
  _inputs = []
  for i in (A, B):
    _add_input(i, _inputs)

  idx = omm.op_counter["Sub"]
  omm.op_counter["Sub"] += 1
  node = onnx.helper.make_node("Sub",
                               _inputs, [f'_t_Sub_{idx}_C'],
                               name=f"Sub_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Sign")
def Sign(input, **kwargs):
  _inputs = []
  for i in (input, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Sign"]
  omm.op_counter["Sign"] += 1
  node = onnx.helper.make_node("Sign",
                               _inputs, [f'_t_Sign_{idx}_output'],
                               name=f"Sign_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.IsNaN")
def IsNaN(X, **kwargs):
  _inputs = []
  for i in (X, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["IsNaN"]
  omm.op_counter["IsNaN"] += 1
  node = onnx.helper.make_node("IsNaN",
                               _inputs, [f'_t_IsNaN_{idx}_Y'],
                               name=f"IsNaN_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Max")
def Max(data_0, **kwargs):
  _inputs = []
  for i in (data_0, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Max"]
  omm.op_counter["Max"] += 1
  node = onnx.helper.make_node("Max",
                               _inputs, [f'_t_Max_{idx}_max'],
                               name=f"Max_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Mod")
def Mod(A, B, **kwargs):
  _inputs = []
  for i in (A, B):
    _add_input(i, _inputs)

  idx = omm.op_counter["Mod"]
  omm.op_counter["Mod"] += 1
  node = onnx.helper.make_node("Mod",
                               _inputs, [f'_t_Mod_{idx}_C'],
                               name=f"Mod_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.ReduceProd")
def ReduceProd(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceProd"]
  omm.op_counter["ReduceProd"] += 1
  node = onnx.helper.make_node("ReduceProd",
                               _inputs, [f'_t_ReduceProd_{idx}_reduced'],
                               name=f"ReduceProd_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.DequantizeLinear")
def DequantizeLinear(x, x_scale, x_zero_point=None, **kwargs):
  _inputs = []
  for i in (x, x_scale, x_zero_point):
    _add_input(i, _inputs)

  idx = omm.op_counter["DequantizeLinear"]
  omm.op_counter["DequantizeLinear"] += 1
  node = onnx.helper.make_node("DequantizeLinear",
                               _inputs, [f'_t_DequantizeLinear_{idx}_y'],
                               name=f"DequantizeLinear_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.ReduceL1")
def ReduceL1(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceL1"]
  omm.op_counter["ReduceL1"] += 1
  node = onnx.helper.make_node("ReduceL1",
                               _inputs, [f'_t_ReduceL1_{idx}_reduced'],
                               name=f"ReduceL1_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Expand")
def Expand(input, shape, **kwargs):
  _inputs = []
  for i in (input, shape):
    _add_input(i, _inputs)

  idx = omm.op_counter["Expand"]
  omm.op_counter["Expand"] += 1
  node = onnx.helper.make_node("Expand",
                               _inputs, [f'_t_Expand_{idx}_output'],
                               name=f"Expand_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.ReduceSum")
def ReduceSum(data, axes=None, **kwargs):
  _inputs = []
  for i in (data, axes):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceSum"]
  omm.op_counter["ReduceSum"] += 1
  node = onnx.helper.make_node("ReduceSum",
                               _inputs, [f'_t_ReduceSum_{idx}_reduced'],
                               name=f"ReduceSum_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Floor")
def Floor(X, **kwargs):
  _inputs = []
  for i in (X, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Floor"]
  omm.op_counter["Floor"] += 1
  node = onnx.helper.make_node("Floor",
                               _inputs, [f'_t_Floor_{idx}_Y'],
                               name=f"Floor_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.ReduceSumSquare")
def ReduceSumSquare(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceSumSquare"]
  omm.op_counter["ReduceSumSquare"] += 1
  node = onnx.helper.make_node("ReduceSumSquare",
                               _inputs, [f'_t_ReduceSumSquare_{idx}_reduced'],
                               name=f"ReduceSumSquare_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Tile")
def Tile(input, repeats, **kwargs):
  _inputs = []
  for i in (input, repeats):
    _add_input(i, _inputs)

  idx = omm.op_counter["Tile"]
  omm.op_counter["Tile"] += 1
  node = onnx.helper.make_node("Tile",
                               _inputs, [f'_t_Tile_{idx}_output'],
                               name=f"Tile_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Squeeze")
def Squeeze(data, axes=None, **kwargs):
  _inputs = []
  for i in (data, axes):
    _add_input(i, _inputs)

  idx = omm.op_counter["Squeeze"]
  omm.op_counter["Squeeze"] += 1
  node = onnx.helper.make_node("Squeeze",
                               _inputs, [f'_t_Squeeze_{idx}_squeezed'],
                               name=f"Squeeze_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.ReduceLogSum")
def ReduceLogSum(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceLogSum"]
  omm.op_counter["ReduceLogSum"] += 1
  node = onnx.helper.make_node("ReduceLogSum",
                               _inputs, [f'_t_ReduceLogSum_{idx}_reduced'],
                               name=f"ReduceLogSum_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Split")
def Split(input, split=None, **kwargs):
  _inputs = []
  for i in (input, split):
    _add_input(i, _inputs)

  idx = omm.op_counter["Split"]
  omm.op_counter["Split"] += 1
  node = onnx.helper.make_node("Split",
                               _inputs, [f"_t_Split_{idx}_{i}" for i in range(len(split))],
                               name=f"Split_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Sqrt")
def Sqrt(X, **kwargs):
  _inputs = []
  for i in (X, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Sqrt"]
  omm.op_counter["Sqrt"] += 1
  node = onnx.helper.make_node("Sqrt",
                               _inputs, [f'_t_Sqrt_{idx}_Y'],
                               name=f"Sqrt_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.SpaceToDepth")
def SpaceToDepth(input, **kwargs):
  _inputs = []
  for i in (input, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["SpaceToDepth"]
  omm.op_counter["SpaceToDepth"] += 1
  node = onnx.helper.make_node("SpaceToDepth",
                               _inputs, [f'_t_SpaceToDepth_{idx}_output'],
                               name=f"SpaceToDepth_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Softmax")
def Softmax(input, **kwargs):
  _inputs = []
  for i in (input, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Softmax"]
  omm.op_counter["Softmax"] += 1
  node = onnx.helper.make_node("Softmax",
                               _inputs, [f'_t_Softmax_{idx}_output'],
                               name=f"Softmax_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Erf")
def Erf(input, **kwargs):
  _inputs = []
  for i in (input, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Erf"]
  omm.op_counter["Erf"] += 1
  node = onnx.helper.make_node("Erf",
                               _inputs, [f'_t_Erf_{idx}_output'],
                               name=f"Erf_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Size")
def Size(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Size"]
  omm.op_counter["Size"] += 1
  node = onnx.helper.make_node("Size",
                               _inputs, [f'_t_Size_{idx}_size'],
                               name=f"Size_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Tanh")
def Tanh(input, **kwargs):
  _inputs = []
  for i in (input, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Tanh"]
  omm.op_counter["Tanh"] += 1
  node = onnx.helper.make_node("Tanh",
                               _inputs, [f'_t_Tanh_{idx}_output'],
                               name=f"Tanh_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Transpose")
def Transpose(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Transpose"]
  omm.op_counter["Transpose"] += 1
  node = onnx.helper.make_node("Transpose",
                               _inputs, [f'_t_Transpose_{idx}_transposed'],
                               name=f"Transpose_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Shape")
def Shape(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Shape"]
  omm.op_counter["Shape"] += 1
  node = onnx.helper.make_node("Shape",
                               _inputs, [f'_t_Shape_{idx}_shape'],
                               name=f"Shape_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Sum")
def Sum(data_0, **kwargs):
  _inputs = []
  for i in (data_0, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Sum"]
  omm.op_counter["Sum"] += 1
  node = onnx.helper.make_node("Sum",
                               _inputs, [f'_t_Sum_{idx}_sum'],
                               name=f"Sum_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Relu")
def Relu(X, **kwargs):
  _inputs = []
  for i in (X, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Relu"]
  omm.op_counter["Relu"] += 1
  node = onnx.helper.make_node("Relu",
                               _inputs, [f'_t_Relu_{idx}_Y'],
                               name=f"Relu_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.NegativeLogLikelihoodLoss")
def NegativeLogLikelihoodLoss(input, target, weight=None, **kwargs):
  _inputs = []
  for i in (input, target, weight):
    _add_input(i, _inputs)

  idx = omm.op_counter["NegativeLogLikelihoodLoss"]
  omm.op_counter["NegativeLogLikelihoodLoss"] += 1
  node = onnx.helper.make_node("NegativeLogLikelihoodLoss",
                               _inputs, [f'_t_NegativeLogLikelihoodLoss_{idx}_loss'],
                               name=f"NegativeLogLikelihoodLoss_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.ReduceMin")
def ReduceMin(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceMin"]
  omm.op_counter["ReduceMin"] += 1
  node = onnx.helper.make_node("ReduceMin",
                               _inputs, [f'_t_ReduceMin_{idx}_reduced'],
                               name=f"ReduceMin_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Mul")
def Mul(A, B, **kwargs):
  _inputs = []
  for i in (A, B):
    _add_input(i, _inputs)

  idx = omm.op_counter["Mul"]
  omm.op_counter["Mul"] += 1
  node = onnx.helper.make_node("Mul",
                               _inputs, [f'_t_Mul_{idx}_C'],
                               name=f"Mul_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Pad")
def Pad(data, pads, constant_value=None, **kwargs):
  _inputs = []
  for i in (data, pads, constant_value):
    _add_input(i, _inputs)

  idx = omm.op_counter["Pad"]
  omm.op_counter["Pad"] += 1
  node = onnx.helper.make_node("Pad",
                               _inputs, [f'_t_Pad_{idx}_output'],
                               name=f"Pad_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Slice")
def Slice(data, starts, ends, axes=None, steps=None, **kwargs):
  _inputs = []
  for i in (data, starts, ends, axes, steps):
    _add_input(i, _inputs)

  idx = omm.op_counter["Slice"]
  omm.op_counter["Slice"] += 1
  node = onnx.helper.make_node("Slice",
                               _inputs, [f'_t_Slice_{idx}_output'],
                               name=f"Slice_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Greater")
def Greater(A, B, **kwargs):
  _inputs = []
  for i in (A, B):
    _add_input(i, _inputs)

  idx = omm.op_counter["Greater"]
  omm.op_counter["Greater"] += 1
  node = onnx.helper.make_node("Greater",
                               _inputs, [f'_t_Greater_{idx}_C'],
                               name=f"Greater_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.ReduceLogSumExp")
def ReduceLogSumExp(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceLogSumExp"]
  omm.op_counter["ReduceLogSumExp"] += 1
  node = onnx.helper.make_node("ReduceLogSumExp",
                               _inputs, [f'_t_ReduceLogSumExp_{idx}_reduced'],
                               name=f"ReduceLogSumExp_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Neg")
def Neg(X, **kwargs):
  _inputs = []
  for i in (X, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Neg"]
  omm.op_counter["Neg"] += 1
  node = onnx.helper.make_node("Neg",
                               _inputs, [f'_t_Neg_{idx}_Y'],
                               name=f"Neg_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Reshape")
def Reshape(data, shape, **kwargs):
  _inputs = []
  for i in (data, shape):
    _add_input(i, _inputs)

  idx = omm.op_counter["Reshape"]
  omm.op_counter["Reshape"] += 1
  node = onnx.helper.make_node("Reshape",
                               _inputs, [f'_t_Reshape_{idx}_reshaped'],
                               name=f"Reshape_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.ReduceL2")
def ReduceL2(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceL2"]
  omm.op_counter["ReduceL2"] += 1
  node = onnx.helper.make_node("ReduceL2",
                               _inputs, [f'_t_ReduceL2_{idx}_reduced'],
                               name=f"ReduceL2_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Min")
def Min(data_0, **kwargs):
  _inputs = []
  for i in (data_0, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Min"]
  omm.op_counter["Min"] += 1
  node = onnx.helper.make_node("Min",
                               _inputs, [f'_t_Min_{idx}_min'],
                               name=f"Min_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Flatten")
def Flatten(input, **kwargs):
  _inputs = []
  for i in (input, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Flatten"]
  omm.op_counter["Flatten"] += 1
  node = onnx.helper.make_node("Flatten",
                               _inputs, [f'_t_Flatten_{idx}_output'],
                               name=f"Flatten_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.ReduceMax")
def ReduceMax(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceMax"]
  omm.op_counter["ReduceMax"] += 1
  node = onnx.helper.make_node("ReduceMax",
                               _inputs, [f'_t_ReduceMax_{idx}_reduced'],
                               name=f"ReduceMax_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Loop")
def Loop(M, cond, v_initial=None, **kwargs):
  _inputs = []
  for i in (M, cond, v_initial):
    _add_input(i, _inputs)

  idx = omm.op_counter["Loop"]
  omm.op_counter["Loop"] += 1
  node = onnx.helper.make_node("Loop",
                               _inputs, [f'_t_Loop_{idx}_v_final_and_scan_outputs'],
                               name=f"Loop_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Log")
def Log(input, **kwargs):
  _inputs = []
  for i in (input, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Log"]
  omm.op_counter["Log"] += 1
  node = onnx.helper.make_node("Log",
                               _inputs, [f'_t_Log_{idx}_output'],
                               name=f"Log_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Cast")
def Cast(input, **kwargs):
  _inputs = []
  for i in (input, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Cast"]
  omm.op_counter["Cast"] += 1
  node = onnx.helper.make_node("Cast",
                               _inputs, [f'_t_Cast_{idx}_output'],
                               name=f"Cast_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Unsqueeze")
def Unsqueeze(data, axes, **kwargs):
  _inputs = []
  for i in (data, axes):
    _add_input(i, _inputs)

  idx = omm.op_counter["Unsqueeze"]
  omm.op_counter["Unsqueeze"] += 1
  node = onnx.helper.make_node("Unsqueeze",
                               _inputs, [f'_t_Unsqueeze_{idx}_expanded'],
                               name=f"Unsqueeze_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.ArgMax")
def ArgMax(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ArgMax"]
  omm.op_counter["ArgMax"] += 1
  node = onnx.helper.make_node("ArgMax",
                               _inputs, [f'_t_ArgMax_{idx}_reduced'],
                               name=f"ArgMax_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.LRN")
def LRN(X, **kwargs):
  _inputs = []
  for i in (X, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["LRN"]
  omm.op_counter["LRN"] += 1
  node = onnx.helper.make_node("LRN",
                               _inputs, [f'_t_LRN_{idx}_Y'],
                               name=f"LRN_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Less")
def Less(A, B, **kwargs):
  _inputs = []
  for i in (A, B):
    _add_input(i, _inputs)

  idx = omm.op_counter["Less"]
  omm.op_counter["Less"] += 1
  node = onnx.helper.make_node("Less",
                               _inputs, [f'_t_Less_{idx}_C'],
                               name=f"Less_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Exp")
def Exp(input, **kwargs):
  _inputs = []
  for i in (input, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Exp"]
  omm.op_counter["Exp"] += 1
  node = onnx.helper.make_node("Exp",
                               _inputs, [f'_t_Exp_{idx}_output'],
                               name=f"Exp_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.SoftmaxCrossEntropyLoss")
def SoftmaxCrossEntropyLoss(scores, labels, weights=None, **kwargs):
  _inputs = []
  for i in (scores, labels, weights):
    _add_input(i, _inputs)

  idx = omm.op_counter["SoftmaxCrossEntropyLoss"]
  omm.op_counter["SoftmaxCrossEntropyLoss"] += 1
  node = onnx.helper.make_node("SoftmaxCrossEntropyLoss",
                               _inputs, [f'_t_SoftmaxCrossEntropyLoss_{idx}_output', f'_t_SoftmaxCrossEntropyLoss_{idx}_log_prob'],
                               name=f"SoftmaxCrossEntropyLoss_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Concat")
def Concat(inputs, **kwargs):
  _inputs = []
  for i in (inputs, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Concat"]
  omm.op_counter["Concat"] += 1
  node = onnx.helper.make_node("Concat",
                               _inputs, [f'_t_Concat_{idx}_concat_result'],
                               name=f"Concat_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.If")
def If(cond, **kwargs):
  _inputs = []
  for i in (cond, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["If"]
  omm.op_counter["If"] += 1
  node = onnx.helper.make_node("If",
                               _inputs, [f'_t_If_{idx}_outputs'],
                               name=f"If_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Clip")
def Clip(input, min=None, max=None, **kwargs):
  _inputs = []
  for i in (input, min, max):
    _add_input(i, _inputs)

  idx = omm.op_counter["Clip"]
  omm.op_counter["Clip"] += 1
  node = onnx.helper.make_node("Clip",
                               _inputs, [f'_t_Clip_{idx}_output'],
                               name=f"Clip_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Abs")
def Abs(X, **kwargs):
  _inputs = []
  for i in (X, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Abs"]
  omm.op_counter["Abs"] += 1
  node = onnx.helper.make_node("Abs",
                               _inputs, [f'_t_Abs_{idx}_Y'],
                               name=f"Abs_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Identity")
def Identity(input, **kwargs):
  _inputs = []
  for i in (input, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Identity"]
  omm.op_counter["Identity"] += 1
  node = onnx.helper.make_node("Identity",
                               _inputs, [f'_t_Identity_{idx}_output'],
                               name=f"Identity_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.MatMul")
def MatMul(A, B, **kwargs):
  _inputs = []
  for i in (A, B):
    _add_input(i, _inputs)

  idx = omm.op_counter["MatMul"]
  omm.op_counter["MatMul"] += 1
  node = onnx.helper.make_node("MatMul",
                               _inputs, [f'_t_MatMul_{idx}_Y'],
                               name=f"MatMul_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Resize")
def Resize(X, roi=None, scales=None, sizes=None, **kwargs):
  _inputs = []
  for i in (X, roi, scales, sizes):
    _add_input(i, _inputs)

  idx = omm.op_counter["Resize"]
  omm.op_counter["Resize"] += 1
  node = onnx.helper.make_node("Resize",
                               _inputs, [f'_t_Resize_{idx}_Y'],
                               name=f"Resize_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.ArgMin")
def ArgMin(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ArgMin"]
  omm.op_counter["ArgMin"] += 1
  node = onnx.helper.make_node("ArgMin",
                               _inputs, [f'_t_ArgMin_{idx}_reduced'],
                               name=f"ArgMin_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Add")
def Add(A, B, **kwargs):
  _inputs = []
  for i in (A, B):
    _add_input(i, _inputs)

  idx = omm.op_counter["Add"]
  omm.op_counter["Add"] += 1
  node = onnx.helper.make_node("Add",
                               _inputs, [f'_t_Add_{idx}_C'],
                               name=f"Add_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Constant")
def Constant(**kwargs):
  _inputs = []
  for i in ():
    _add_input(i, _inputs)

  idx = omm.op_counter["Constant"]
  omm.op_counter["Constant"] += 1
  node = onnx.helper.make_node("Constant",
                               _inputs, [f'_t_Constant_{idx}_output'],
                               name=f"Constant_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Pow")
def Pow(X, Y, **kwargs):
  _inputs = []
  for i in (X, Y):
    _add_input(i, _inputs)

  idx = omm.op_counter["Pow"]
  omm.op_counter["Pow"] += 1
  node = onnx.helper.make_node("Pow",
                               _inputs, [f'_t_Pow_{idx}_Z'],
                               name=f"Pow_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Div")
def Div(A, B, **kwargs):
  _inputs = []
  for i in (A, B):
    _add_input(i, _inputs)

  idx = omm.op_counter["Div"]
  omm.op_counter["Div"] += 1
  node = onnx.helper.make_node("Div",
                               _inputs, [f'_t_Div_{idx}_C'],
                               name=f"Div_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.ReduceMean")
def ReduceMean(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceMean"]
  omm.op_counter["ReduceMean"] += 1
  node = onnx.helper.make_node("ReduceMean",
                               _inputs, [f'_t_ReduceMean_{idx}_reduced'],
                               name=f"ReduceMean_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Dropout")
def Dropout(data, ratio=None, training_mode=None, **kwargs):
  _inputs = []
  for i in (data, ratio, training_mode):
    _add_input(i, _inputs)

  idx = omm.op_counter["Dropout"]
  omm.op_counter["Dropout"] += 1
  node = onnx.helper.make_node("Dropout",
                               _inputs, [f'_t_Dropout_{idx}_output', f'_t_Dropout_{idx}_mask'],
                               name=f"Dropout_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.DepthToSpace")
def DepthToSpace(input, **kwargs):
  _inputs = []
  for i in (input, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["DepthToSpace"]
  omm.op_counter["DepthToSpace"] += 1
  node = onnx.helper.make_node("DepthToSpace",
                               _inputs, [f'_t_DepthToSpace_{idx}_output'],
                               name=f"DepthToSpace_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Ceil")
def Ceil(X, **kwargs):
  _inputs = []
  for i in (X, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Ceil"]
  omm.op_counter["Ceil"] += 1
  node = onnx.helper.make_node("Ceil",
                               _inputs, [f'_t_Ceil_{idx}_Y'],
                               name=f"Ceil_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v13.Hardmax")
def Hardmax(input, **kwargs):
  _inputs = []
  for i in (input, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Hardmax"]
  omm.op_counter["Hardmax"] += 1
  node = onnx.helper.make_node("Hardmax",
                               _inputs, [f'_t_Hardmax_{idx}_output'],
                               name=f"Hardmax_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node
