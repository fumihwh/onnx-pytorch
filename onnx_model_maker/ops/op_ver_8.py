# Autogenerated by onnx-model-maker. Don't modify it manually.

import onnx
import onnx.helper
import onnx.numpy_helper
from onnx_model_maker import omm
from onnx_model_maker import onnx_mm_export
from onnx_model_maker.ops.op_helper import _add_input


@onnx_mm_export("v8.Mean")
def Mean(data_0, **kwargs):
  _inputs = []
  for i in (data_0, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Mean"]
  omm.op_counter["Mean"] += 1
  node = onnx.helper.make_node("Mean",
                               _inputs, [f'_t_Mean_{idx}_mean'],
                               name=f"Mean_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v8.Max")
def Max(data_0, **kwargs):
  _inputs = []
  for i in (data_0, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Max"]
  omm.op_counter["Max"] += 1
  node = onnx.helper.make_node("Max",
                               _inputs, [f'_t_Max_{idx}_max'],
                               name=f"Max_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v8.Scan")
def Scan(sequence_lens, initial_state_and_scan_inputs, **kwargs):
  _inputs = []
  for i in (sequence_lens, initial_state_and_scan_inputs):
    _add_input(i, _inputs)

  idx = omm.op_counter["Scan"]
  omm.op_counter["Scan"] += 1
  node = onnx.helper.make_node("Scan",
                               _inputs, [f'_t_Scan_{idx}_final_state_and_scan_outputs'],
                               name=f"Scan_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v8.Expand")
def Expand(input, shape, **kwargs):
  _inputs = []
  for i in (input, shape):
    _add_input(i, _inputs)

  idx = omm.op_counter["Expand"]
  omm.op_counter["Expand"] += 1
  node = onnx.helper.make_node("Expand",
                               _inputs, [f'_t_Expand_{idx}_output'],
                               name=f"Expand_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v8.Sum")
def Sum(data_0, **kwargs):
  _inputs = []
  for i in (data_0, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Sum"]
  omm.op_counter["Sum"] += 1
  node = onnx.helper.make_node("Sum",
                               _inputs, [f'_t_Sum_{idx}_sum'],
                               name=f"Sum_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v8.Min")
def Min(data_0, **kwargs):
  _inputs = []
  for i in (data_0, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Min"]
  omm.op_counter["Min"] += 1
  node = onnx.helper.make_node("Min",
                               _inputs, [f'_t_Min_{idx}_min'],
                               name=f"Min_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v8.MaxPool")
def MaxPool(X, **kwargs):
  _inputs = []
  for i in (X, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["MaxPool"]
  omm.op_counter["MaxPool"] += 1
  node = onnx.helper.make_node("MaxPool",
                               _inputs, [f'_t_MaxPool_{idx}_Y', f'_t_MaxPool_{idx}_Indices'],
                               name=f"MaxPool_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node
