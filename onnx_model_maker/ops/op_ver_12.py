# Autogenerated by onnx-model-maker. Don't modify it manually.

import onnx
import onnx.helper
import onnx.numpy_helper
from onnx_model_maker import omm
from onnx_model_maker import onnx_mm_export
from onnx_model_maker.ops.op_helper import _add_input


@onnx_mm_export("v12.LessOrEqual")
def LessOrEqual(A, B, **kwargs):
  _inputs = []
  for i in (A, B):
    _add_input(i, _inputs)

  idx = omm.op_counter["LessOrEqual"]
  omm.op_counter["LessOrEqual"] += 1
  node = onnx.helper.make_node("LessOrEqual",
                               _inputs, [f'_t_LessOrEqual_{idx}_C'],
                               name=f"LessOrEqual_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v12.Celu")
def Celu(X, **kwargs):
  _inputs = []
  for i in (X, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Celu"]
  omm.op_counter["Celu"] += 1
  node = onnx.helper.make_node("Celu",
                               _inputs, [f'_t_Celu_{idx}_Y'],
                               name=f"Celu_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v12.GatherND")
def GatherND(data, indices, **kwargs):
  _inputs = []
  for i in (data, indices):
    _add_input(i, _inputs)

  idx = omm.op_counter["GatherND"]
  omm.op_counter["GatherND"] += 1
  node = onnx.helper.make_node("GatherND",
                               _inputs, [f'_t_GatherND_{idx}_output'],
                               name=f"GatherND_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v12.Max")
def Max(data_0, **kwargs):
  _inputs = []
  for i in (data_0, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Max"]
  omm.op_counter["Max"] += 1
  node = onnx.helper.make_node("Max",
                               _inputs, [f'_t_Max_{idx}_max'],
                               name=f"Max_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v12.Einsum")
def Einsum(Inputs, **kwargs):
  _inputs = []
  for i in (Inputs, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Einsum"]
  omm.op_counter["Einsum"] += 1
  node = onnx.helper.make_node("Einsum",
                               _inputs, [f'_t_Einsum_{idx}_Output'],
                               name=f"Einsum_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v12.GreaterOrEqual")
def GreaterOrEqual(A, B, **kwargs):
  _inputs = []
  for i in (A, B):
    _add_input(i, _inputs)

  idx = omm.op_counter["GreaterOrEqual"]
  omm.op_counter["GreaterOrEqual"] += 1
  node = onnx.helper.make_node("GreaterOrEqual",
                               _inputs, [f'_t_GreaterOrEqual_{idx}_C'],
                               name=f"GreaterOrEqual_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v12.NegativeLogLikelihoodLoss")
def NegativeLogLikelihoodLoss(input, target, weight=None, **kwargs):
  _inputs = []
  for i in (input, target, weight):
    _add_input(i, _inputs)

  idx = omm.op_counter["NegativeLogLikelihoodLoss"]
  omm.op_counter["NegativeLogLikelihoodLoss"] += 1
  node = onnx.helper.make_node("NegativeLogLikelihoodLoss",
                               _inputs, [f'_t_NegativeLogLikelihoodLoss_{idx}_loss'],
                               name=f"NegativeLogLikelihoodLoss_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v12.ReduceMin")
def ReduceMin(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceMin"]
  omm.op_counter["ReduceMin"] += 1
  node = onnx.helper.make_node("ReduceMin",
                               _inputs, [f'_t_ReduceMin_{idx}_reduced'],
                               name=f"ReduceMin_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v12.Min")
def Min(data_0, **kwargs):
  _inputs = []
  for i in (data_0, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["Min"]
  omm.op_counter["Min"] += 1
  node = onnx.helper.make_node("Min",
                               _inputs, [f'_t_Min_{idx}_min'],
                               name=f"Min_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v12.ReduceMax")
def ReduceMax(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ReduceMax"]
  omm.op_counter["ReduceMax"] += 1
  node = onnx.helper.make_node("ReduceMax",
                               _inputs, [f'_t_ReduceMax_{idx}_reduced'],
                               name=f"ReduceMax_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v12.ArgMax")
def ArgMax(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ArgMax"]
  omm.op_counter["ArgMax"] += 1
  node = onnx.helper.make_node("ArgMax",
                               _inputs, [f'_t_ArgMax_{idx}_reduced'],
                               name=f"ArgMax_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v12.SoftmaxCrossEntropyLoss")
def SoftmaxCrossEntropyLoss(scores, labels, weights=None, **kwargs):
  _inputs = []
  for i in (scores, labels, weights):
    _add_input(i, _inputs)

  idx = omm.op_counter["SoftmaxCrossEntropyLoss"]
  omm.op_counter["SoftmaxCrossEntropyLoss"] += 1
  node = onnx.helper.make_node("SoftmaxCrossEntropyLoss",
                               _inputs, [f'_t_SoftmaxCrossEntropyLoss_{idx}_output', f'_t_SoftmaxCrossEntropyLoss_{idx}_log_prob'],
                               name=f"SoftmaxCrossEntropyLoss_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v12.Clip")
def Clip(input, min=None, max=None, **kwargs):
  _inputs = []
  for i in (input, min, max):
    _add_input(i, _inputs)

  idx = omm.op_counter["Clip"]
  omm.op_counter["Clip"] += 1
  node = onnx.helper.make_node("Clip",
                               _inputs, [f'_t_Clip_{idx}_output'],
                               name=f"Clip_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v12.ArgMin")
def ArgMin(data, **kwargs):
  _inputs = []
  for i in (data, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["ArgMin"]
  omm.op_counter["ArgMin"] += 1
  node = onnx.helper.make_node("ArgMin",
                               _inputs, [f'_t_ArgMin_{idx}_reduced'],
                               name=f"ArgMin_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v12.Constant")
def Constant(**kwargs):
  _inputs = []
  for i in ():
    _add_input(i, _inputs)

  idx = omm.op_counter["Constant"]
  omm.op_counter["Constant"] += 1
  node = onnx.helper.make_node("Constant",
                               _inputs, [f'_t_Constant_{idx}_output'],
                               name=f"Constant_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v12.Pow")
def Pow(X, Y, **kwargs):
  _inputs = []
  for i in (X, Y):
    _add_input(i, _inputs)

  idx = omm.op_counter["Pow"]
  omm.op_counter["Pow"] += 1
  node = onnx.helper.make_node("Pow",
                               _inputs, [f'_t_Pow_{idx}_Z'],
                               name=f"Pow_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v12.MaxPool")
def MaxPool(X, **kwargs):
  _inputs = []
  for i in (X, ):
    _add_input(i, _inputs)

  idx = omm.op_counter["MaxPool"]
  omm.op_counter["MaxPool"] += 1
  node = onnx.helper.make_node("MaxPool",
                               _inputs, [f'_t_MaxPool_{idx}_Y', f'_t_MaxPool_{idx}_Indices'],
                               name=f"MaxPool_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node


@onnx_mm_export("v12.Dropout")
def Dropout(data, ratio=None, training_mode=None, **kwargs):
  _inputs = []
  for i in (data, ratio, training_mode):
    _add_input(i, _inputs)

  idx = omm.op_counter["Dropout"]
  omm.op_counter["Dropout"] += 1
  node = onnx.helper.make_node("Dropout",
                               _inputs, [f'_t_Dropout_{idx}_output', f'_t_Dropout_{idx}_mask'],
                               name=f"Dropout_{idx}",
                               **kwargs)
  onnx.checker.check_node(node, omm.ctx)
  omm.model.graph.node.append(node)
  return node
